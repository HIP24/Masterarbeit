{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#thema-masterarbeit","title":"Thema Masterarbeit","text":"<p>Virtualisierung eines Echtzeit-Betriebssystems zur Steuerung eines Roboters mit Schwerpunkt auf die  Einhaltung der Echtzeit </p>"},{"location":"#kurze-umschreibung","title":"Kurze Umschreibung","text":"<p>Erstellung einer Echtzeit-Robotersteuerungsplattform unter Verwendung von Salamander OS, Xenomai, QEMU  und PCV-521 in der Yocto-Umgebung. Die Plattform basiert auf Salamander OS und nutzt Xenomai f\u00fcr Echtzeit- Funktionen. Dazu muss im ersten Schritt die Virtualisierungsplattform evaluiert werden. (QEMU, Hyper-V, Virtual  Box, etc.) Als weiterer Schritt folgt die Anbindung eines Roboters \u00fcber eine VARAN-Bus Schnittstelle. Das  gesamte System wird in der Yocto-Umgebung erstellt und konfiguriert.  Das Hauptziel der Arbeit ist es, herauszufinden, wie die Integration von Echtzeit-Funktionen und effizienten  Kommunikationssystemen in eine Robotersteuerungsplattform die Reaktionszeit und Zuverl\u00e4ssigkeit von  Roboteranwendungen verbessern kann. </p>"},{"location":"#masterarbeit","title":"Masterarbeit","text":"<p>Hier ist die Masterarbeit.</p> <p>Info</p> <p>Diese Masterarbeit wird t\u00e4glich aktualisiert. Zu einem sp\u00e4teren Zeitpunkt kann mehr Inhalt vorhanden sein.</p> Fortschritt  der Masterarbeit:"},{"location":"general/checklist/","title":"Checklist","text":""},{"location":"general/checklist/#done","title":"Done","text":"<ul> <li> Install Ubuntu 22.04.3 LTS</li> <li> Local Yocto Build: Salamander4 </li> <li> Linux Kernel Configuration with Xenomai</li> <li> Boot Salamander4 in QEMU under native Ubuntu </li> <li> Configured bridge for QEMU</li> <li> Connected LasalClass2 with [Salamander 4]</li> <li> Enabled access to the vsocket for guest</li> <li> trace-cmd and kernelshark with Salamander4 as guest </li> <li> Used the Xenomai test suite: latency -T 60` </li> <li> Isolated host CPU for guest</li> <li> Latency got better after isolation</li> <li> Analyze Host and Guest Processes</li> <li> Latency got much better after rt-patch</li> <li> Latency got even better after Intels RT_Performance_Tuning_Best_Practice_KVM_VM.pdf: xenomai_compare.md</li> </ul>"},{"location":"general/checklist/#missing","title":"Missing","text":"<ul> <li> Inspect kvm_exit reasons</li> <li> Adapt QEMU script to work with chrt</li> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"general/checklist/#appendix-hardware-and-os-configuration-checklist","title":"Appendix: Hardware and OS configuration checklist","text":"<p>Real-time programming with Linux This serves as a non-exhaustive starting point on the things to check for the hardware and OS. The list is constructed based on my survey of the literature (mostly conference talks, with some internet articles). Remember to always validate the final scheduling latency with something like cyclictest!</p> <ul> <li> Disable SMT</li> <li> Disable dynamic frequency scaling</li> <li> Check for the presence of system management interrupts; if possible, consult with the hardware vendor (remember to always verify their claims)</li> <li> Understand the NUMA of the computer and minimize cross-node memory access within the RT process</li> <li> Disable RT throttling</li> <li> Disable any unneeded RT services/daemons already running on the OS</li> <li> Possibly setup isolcpu (or use cgroups to accomplish the same thing)</li> <li>[] Look into kernel configurations that may affect RT performance such as CONFIG_LOCKUP_DETECTOR, CONFIG_DETECT_HUNG_TASK, CONFIG_NO_HZ, CONFIG_HZ_*, CONFIG_NO_HZ_FULL, and possibly more.</li> <li>[] Configure the memory lock and rtprio permissions in /etc/security/limits.d.</li> <li> Do the latency_reduction_steps.md</li> <li>[]</li> </ul>"},{"location":"general/components/","title":"Components","text":""},{"location":"general/components/#angabe","title":"Angabe","text":"<p>Virtualisierung eines Echtzeit-Betriebssystems zur Steuerung eines Roboters mit Schwerpunkt auf die Einhaltung der Echtzeit</p>"},{"location":"general/components/#yocto-umgebung","title":"Yocto-Umgebung","text":"<p>Build with Yocto</p>"},{"location":"general/components/#salamander-os","title":"Salamander OS","text":"<p>Build LRT</p>"},{"location":"general/components/#xenomai","title":"Xenomai","text":"<p>Preempt_rt.png Xenomai.png</p>"},{"location":"general/components/#lasal-class","title":"Lasal CLass","text":"<p>Lasal Class 2 english Lasal Class 2 deutsch</p>"},{"location":"general/components/#qemu","title":"QEMU","text":"<p>QEMU documentation</p>"},{"location":"general/components/#pcv-521","title":"PCV-521","text":"<p>PCI-Einsteckmodul, das als Schnittstelle zwischen einem PC und dem VARAN-Bus dient PCV 522.pdf </p>"},{"location":"general/documentations_and_links/","title":"Documentations","text":"<ul> <li>Yocto Project</li> <li>QEMU</li> <li>Paravirtualized KVM features</li> <li>QEMU options</li> <li>Kernel Parameters</li> <li>Xenomai</li> <li>Trace-cmd</li> <li>KernelShark</li> <li>Kernelconfig</li> <li>Sigmatek <ul> <li>Build with Yocto</li> <li>Build LRT</li> </ul> </li> </ul>"},{"location":"general/documentations_and_links/#links","title":"Links","text":""},{"location":"general/documentations_and_links/#ftrace","title":"ftrace","text":"<p>Analyze the Linux kernel with ftrace ftrace - Function Tracer ftrace: trace your kernel functions! </p>"},{"location":"general/documentations_and_links/#trace-cmd","title":"trace-cmd","text":"<p>Youtube: Tracing VMs Seeing How Host and Guest Interact - Steven Rostedt, Google trace-cmd Tutorial trace-cmd Presentation trace-cmd Documentation trace-cmd: A front-end for Ftrace Kernel tracing with trace-cmd Git repo trace-cmd </p>"},{"location":"general/documentations_and_links/#sigmatek","title":"Sigmatek","text":"<p>Sigmatek Git Branches</p>"},{"location":"general/documentations_and_links/#ai","title":"AI","text":"<p>ChatGPT prompt splitter</p>"},{"location":"general/draft/","title":"Draft","text":""},{"location":"general/draft/#from-paper-virt-mixed","title":"from Paper Virt. mixed...","text":"<p>Instead, the PREEMPT RT patch provides several mechanisms like high-resolution timers, threaded interrupt handlers, priority inheritance implementation, Preemptible Read-Copy-Update (RCU), real-time schedulers, and a memory allocator.</p>"},{"location":"general/draft/#numa","title":"NUMA","text":"<pre><code>sigma_ibo@sigma-ibo:~$ numactl --hardware\navailable: 1 nodes (0)\nnode 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13\nnode 0 size: 31772 MB\nnode 0 free: 10107 MB\nnode distances:\nnode   0 \n  0:  10\n</code></pre> <p>The output of the numactl --hardware command shows the Non-Uniform Memory Access (NUMA) configuration of your system.</p> <p>Here\u2019s what each line means:</p> <p>available: 1 nodes (0): This means that your system has 1 NUMA node available, and it is identified as node 0. node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13: This line lists the CPUs that are part of node 0. In this case, CPUs 0 through 13 are part of this node. node 0 size: 31772 MB: This indicates that node 0 has a total of 31772 MB of memory. node 0 free: 10107 MB: This shows that out of the total memory, 10107 MB is currently free and available for use. node distances:: This section provides the relative distances between different NUMA nodes. Since you only have one node, there is only one entry here. 0: 10: This indicates that the distance from node 0 to itself is 10. The distance is a relative measure of the latency of memory access between nodes. A lower number means lower latency. Since your system has only one NUMA node, all memory access is local, and you don\u2019t need to worry about cross-node memory access. However, if you add more nodes in the future, you\u2019ll need to consider the placement of processes and memory to minimize cross-node memory access. This can be done by setting CPU and memory affinity for your processes or threads, partitioning data across the NUMA nodes, and using NUMA-aware allocators. Always remember to measure and profile the NUMA characteristics of your application to identify areas where cross-node access is high. If you\u2019re not comfortable making these changes yourself, it might be a good idea to seek help from someone who is.</p> <p>The \u201cdistance\u201d in NUMA architecture doesn\u2019t refer to a physical distance, but rather to a measure of memory access latency. In this context, the distance from a node to itself is the baseline latency for accessing its own local memory.</p> <p>The value \u201c10\u201d is a relative measure. It doesn\u2019t represent an absolute time or delay, but serves as a reference point for comparing memory access latencies within the system. When comparing this to the latency of accessing memory on other nodes (in a multi-node system), a lower value would indicate lower latency.</p> <p>So, when it says the distance from node 0 to itself is 10, it means that the latency for accessing local memory is set as the baseline reference value of 10. If there were other nodes, their distances would be compared to this baseline to determine whether accessing memory on those nodes would be faster or slower.</p> <p>In a single-node system like yours, this value doesn\u2019t have much practical impact since all memory access is local. But in a multi-node system, understanding these distances can be crucial for optimizing performance and minimizing latency.</p>"},{"location":"general/protocol/","title":"Protocol","text":""},{"location":"general/protocol/#dual-boot","title":"Dual Boot","text":"<p>1) Flash SSD by installing etcher 2) Ubuntu and Windows on same machine</p>"},{"location":"general/protocol/#install-salamander4-os","title":"Install Salamander4 OS","text":"<p>1) Install Ubuntu 22.04.3 LTS 2) Do everything in build_with_yocto.md</p>"},{"location":"general/protocol/#ssh-to-device","title":"SSH to device","text":"<p>Connect to device with <code>ssh -oHostKeyAlgorithms=+ssh-rsa root@10.10.1.229</code> or <code>ssh -p 22 root@192.168.1.x</code> (changes often)</p>"},{"location":"general/protocol/#lasalclass2-to-device","title":"LasalClass2 to device","text":"<p>Connect LasalClass2 with Salamander 4, IP of Salamander4 device</p>"},{"location":"general/protocol/#configure-bridge-for-qemu","title":"Configure bridge for QEMU","text":"<p>This setup allows the virtual machines to communicate with the outside network through the Ethernet connection provided by either the laptop or the docking station.</p> name device enp0s31f6 Laptop's Ethernet port enx4cd717733f80 Docking station's Ethernet port <ul> <li>Disable ipv4 and ipv6</li> <li>Enter nmtui</li> <li>Edit Connection and \\&lt;Add&gt;. Select Bridge.</li> <li>Edit and \\&lt;Add&gt; Ethernet.</li> <li>Copy name enx4cd717733f80 (4C:D7:17:73:3F:80) of Wired connection 2</li> <li>Edit Connection of Ethernet connection 1 so that it automatically connects.</li> <li>Activate Connection.</li> <li>Result should look like this and this.</li> <li>More info in nmbridge.md. </li> </ul>"},{"location":"general/protocol/#reduce-latency","title":"Reduce latency","text":"<p>We test the system using the Xenomai test suite - <code>latency</code> - <code>clocktest</code> </p>"},{"location":"general/protocol/#max-latency-default","title":"Max Latency default","text":"<p>Default latency  <pre><code>sigma_ibo@pamhal:$ ps -eo pid,psr,comm | grep qemu\n   7295  10 start_qemu.sh\n   7298  17 qemu-system-x86\n</code></pre></p> <p>latency -h -s -T 600 -g max_latency_default_10min.txt</p> <p>lat worst is 4070.018</p>"},{"location":"general/protocol/#max-latency-with-taskset","title":"Max Latency with taskset","text":"<p>To isolate CPUs on your host system (Ubuntu), you can add the <code>isolcpus</code> option to the kernel boot configuration. Here are the steps you can follow:</p> <ol> <li>Open the GRUB configuration file with a text editor. You can use the <code>nano</code> editor for this. Execute the following command in your terminal:     <pre><code>sudo nano /etc/default/grub\n</code></pre></li> <li>Search for the entry <code>GRUB_CMDLINE_LINUX</code> and add <code>isolcpus=0,1,2,3,4</code> (or the corresponding CPU numbers you want to isolate). It should then look like this:     <pre><code>GRUB_CMDLINE_LINUX=\"isolcpus=0,1,2,3,4\"\n</code></pre></li> <li> <p>Save the changes and close the editor. If you are using <code>nano</code>, you can do this by pressing <code>Ctrl+X</code>, then typing <code>Y</code> to save the changes, and finally pressing <code>Enter</code> to close the editor.</p> </li> <li> <p>Update GRUB with the following command:     <pre><code>sudo update-grub\n</code></pre></p> </li> <li>Reboot your system for the changes to take effect.</li> </ol> <p>Check with: <code>cat /sys/devices/system/cpu/isolated</code></p> <pre><code>sigma_ibo@pamhal:~$ cat /sys/devices/system/cpu/online \n0-19\nsigma_ibo@pamhal:~$ cat /sys/devices/system/cpu/isolated\n0-4\n</code></pre> <p>After taskset on CPU4 with <code>qemu_def_2taskset_vsock_nmbridge.sh</code> <pre><code>sigma_ibo@pamhal:$ ps -eo pid,psr,comm | grep qemu\n   8752   0 start_qemu.sh\n   8755   4 qemu-system-x86\n</code></pre> latency -h -s -T 600 -g max_latency_with_taskset_10min.txt</p> <p>lat worst reduced from 4070.018 to 457.545 with stats</p>"},{"location":"general/protocol/#max-latency-with-rt","title":"Max Latency with rt","text":"<p>Technical details of the real-time preemption RT-Tests HOWTO: Build an RT-application Tuning a real-time kernel Paravirtualized KVM features </p>"},{"location":"general/protocol/#enable-preempt_rt-kernel","title":"Enable Preempt_RT Kernel","text":"<p>Either do everything in kernel-patch.md to patch the kernel and enable Fully Preemptible Kernel (RT), or simply enable Ubuntu Pro's real-time kernel, here.</p> <p>Info</p> <p>Before the isolation of CPU x, both kernel threads and user processes were running on this CPU. The user processes included various applications such as msedge, code, bash and qemu-system-x86.</p> <p>After isolating CPU x, only kernel threads and the qemu-system-x86 process appear to be running on this CPU. There do not appear to be any other user processes running on this CPU.</p> <p>The isolcpus option prevents the kernel from scheduling normal (non-real-time) processes on the isolated CPUs. However, there are some exceptions:</p> <ul> <li>If a process is explicitly set to run on an isolated CPU (for example with taskset), it will run on that CPU even if it is isolated.</li> <li>Some kernel threads can run on isolated CPUs because they are not controlled by the normal scheduler. These include the threads you see in your output, such as kthreadd, migration/4, ksoftirqd/4, kworker/4:0-events and others.</li> <li>Interrupts can be handled on isolated CPUs unless they are explicitly redirected with the irqaffinity option.</li> </ul> <p>latency -T 600</p> <p>lat worst reduced from 457.545 to 32.216 with stats</p>"},{"location":"general/protocol/#realtime-priority","title":"Realtime priority","text":"<p>Danger</p> <p>Setting a real-time priority of 99 for a process means that this process has the highest priority in the system and is executed before all other processes. This can result in other processes, including important system processes, not receiving the CPU time they need to function properly. This can lead to system instability and, in the worst case, to the system becoming unresponsive or \"crashing\".</p> <p>It is important to be careful when using real-time priorities and ensure that other important processes still get the CPU time they need. It might be helpful to gradually increase the real-time priority and observe the effects on the system instead of jumping straight to the highest priority.</p> <p>To see the real-time priorities of all running processes, have a look at thread priorities.</p>"},{"location":"general/protocol/#configuring-the-system-for-real-time","title":"Configuring the system for real-time","text":"<p>For now, PREEMPT_RT is a set of patches that is supposed to be applied on top of mainline Linux. Most Linux distributions do not build it by default, and you will most likely have to do it yourself [3]. How this can be done falls outside the scope of this post, but there are plenty of guides out there. Hopefully in the near future, all of PREEMPT_RT's functionality will be merged in to mainline, and Linux distributions will provide RT-enabled kernels out-of-the-box.</p> <p>Once you successfully compiled the RT kernel, the default hardware and OS configurations are usually not tuned correctly for RT. The following hardware and OS configurations should likely always be checked and tuned: latency_reduction_steps.md</p>"},{"location":"general/protocol/#third-process-is-for-latency-minimization","title":"Third process is for latency minimization","text":"<pre><code>13    2972    2972 qemu-system-x86_64 -M pc,ac FF    -     98\n13    2972    2976 qemu-system-x86_64 -M pc,ac FF    -     98\n13    2972    3292 qemu-system-x86_64 -M pc,ac FF    -     90\n13    2972    8699 qemu-system-x86_64 -M pc,ac FF    -     95\n</code></pre> <p>Salamander 4 latency comparison </p>"},{"location":"general/timeline/","title":"Timeline","text":"Date Log Thursday, 08.02.2024 Dual boot Windows and Ubuntu Friday, 09.02.2024 Booted Salamander 4 on Ubuntu Monday, 12.02.2024 Connected Salamander 4 with SSH Tuesday, 13.02.2024 Connected Salamander 4 with Lasal Class 2 (Christian) after configuring bridge Wednesday, 14.02.2024 Installed Windows VM on Ubuntu, installed Lasal Class 2 on Windows VM, connected with Salamander 4 Thursday, 15.02.2024 Run pumpcontrol example successfully Friday, 16.02.2024 Increased virtual CPU in Windows Monday, 19.02.2024 Xenomai-system-tools Tuesday, 20.02.2024 KernelShark Wednesday, 21.02.2024 Local Yocto Build finally done Thursday, 22.02.2024 trace-cmd agent on guest communicates with host Friday, 23.02.2024 Teammeeting and Germany Monday, 26.02.2024 after_bitbake, kernelshark, paths Tuesday, 27.02.2024 Isolate CPUs on host system and let guest run on it Wednesday, 28.02.2024 Host-Guest timestamp sync works with VM, can view KVM Combo plots, does still not work with Salamander4 Thursday, 29.02.2024 useful_links and search_for_x.py Friday, 01.03.2024 checklist.md, nmbridge.md, understand nmbridge Monday, 04.03.2024 Finally: Negotiated kvm time sync protocol with guest Salamander4 Tuesday, 05.03.2024 lat worst reduced from 374.075 to 87.379 Wednesday, 06.03.2024 Add documentation local server Thursday, 07.03.2024 Start Salamander4 CPU with icecc Friday, 08.03.2024 Merge master and readme Monday, 11.03.2024 Kernel patch, richard meeting and settings.json Tuesday, 12.03.2024 real time priorities with chrt -f 50, no success Wednesday, 13.03.2024 Preventing kernel tasks from being scheduled on CPU4 Thursday, 14.03.2024 irq.md Friday, 15.03.2024 Timer 1000Hz Monday, 18.03.2024 kernel_processes.md, kernelshark, start thesis Tuesday, 19.03.2024 Added Zotero, Ubuntu Pro and Ubuntu PREEMPT_RT Wednesday, 20.03.2024 kvm_exit reasons plot Thursday, 21.03.2024 gitlfs and settings.json, plot with and without taskset, write more thesis Friday, 22.03.2024 Literature paper search Monday, 25.03.2024 Start masterthesis Tuesday, 26.03.2024 Write masterthesis Wednesday, 27.03.2024 Write masterthesis Thursday, 28.03.2024 Write masterthesis Friday, 29.03.2024 Write masterthesis Monday, 01.04.2024 Ostern Tuesday, 02.04.2024 bcc tool Wednesday, 03.04.2024 Write masterthesis APIC_WRITE Thursday, 04.04.2024 defconfig, vapic Friday, 05.04.2024 check_smp_affinity and check_CPU_IRQ_usage Monday, 08.04.2024 kvm_exit_vapic_results Tuesday, 09.04.2024 trace-cmd report analysis Wednesday, 10.04.2024 getconf _NPROCESSORS_CONF Thursday, 11.04.2024 Richard Meeting Friday, 12.04.2024 Spec Monday, 15.04.2024 report.sh Tuesday, 16.04.2024 Updated analyze_trace.py, include in thesis Wednesday, 17.04.2024 Describe host and guest tasks Thursday, 18.04.2024 Read 4 papers Friday, 19.04.2024 Read 5 papers Monday, 22.04.2024 Boot ubuntu anew Tuesday, 23.04.2024 Rebuild workspace Wednesday, 24.04.2024 Rebuild workspace, problem_solution Thursday, 25.04.2024 Rebuild workspace, table IRQ CPU Friday, 26.04.2024 compare.md, ps.sh Monday, 29.04.2024 powersave, balanced, performance Tuesday, 30.04.2024 merge and failed_reason Wednesday, 01.05.2024 Feiertag Thursday, 02.05.2024 Ubuntu real-time kernel Friday, 03.05.2024 Steven yt, analyze_events and analyze_tasks Monday, 06.05.2024 report_hardware Tuesday, 07.05.2024 Richard prios, show_all_threads.py Wednesday, 08.05.2024 failed_reason include CPU, reorganize Thursday, 09.05.2024 Feiertag Friday, 10.05.2024 compare kernels Monday, 13.05.2024 compare config, qemu test with 2 cpus Tuesday, 14.05.2024 Hardware and OS configuration checklist Wednesday, 15.05.2024 FINALLY LATENCY REDUCED WITH STATS and PLOT Thursday, 16.05.2024 reorganize, papers and configs Friday, 17.05.2024 real-time-kernel-tuning websites Monday, 20.05.2024 Feiertag Tuesday, 21.05.2024 read 3 papers, compare_2_files.py Wednesday, 22.05.2024 Configure like Intels RT_Performance_Tuning_Best_Practice_KVM_VM.pdf, results in xenomai_compare.md Thursday, 23.05.2024 reorganize, test Salamander 4 Friday, 24.05.2024 QEMU with 2 CPUs Monday, 27.05.2024 Write thesis Tuesday, 28.05.2024 Write thesis Wednesday, 29.05.2024 Write thesis Thursday, 30.05.2024 Feiertag Friday, 31.05.2024"}]}