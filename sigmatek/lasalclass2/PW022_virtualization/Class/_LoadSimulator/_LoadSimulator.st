//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_LoadSimulator"
	Revision           = "1.3"
	GUID               = "{9FB27D9F-BCEE-4187-9DCE-C4B88640BA6C}"
	RealtimeTask       = "true"
	DefRealtime        = "1 ms"
	CyclicTask         = "true"
	DefCyclictime      = "1 ms"
	BackgroundTask     = "true"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(446,120)"
	Comment            = "this class simulates a higher workload&#13;&#10;in each task&#13;&#10;the additional time can be set in the&#13;&#10;provided servers">
	<Channels>
		<Server Name="ActBgTime" GUID="{CD95E2D2-289D-458E-B705-4D85A78CB4DB}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="the actual time that is needed for&#13;&#10;background is shown here [µs]&#13;&#10;&#13;&#10;use the read method to get this time&#13;&#10;&#13;&#10;via the write method, the time can &#13;&#10;be reset"/>
		<Server Name="ActCyTime" GUID="{938D8E61-3602-4E7D-95E4-5592B9894041}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="the actual time that is needed for&#13;&#10;the cyclic task is shown here [µs]&#13;&#10;&#13;&#10;use the read method to get this time&#13;&#10;&#13;&#10;via the write method, the time can &#13;&#10;be reset"/>
		<Server Name="ActRtTime" GUID="{B8565F52-BC89-4416-8FA1-D8574646BB65}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="the actual time that is needed for&#13;&#10;the realtime task is shown here [µs]&#13;&#10;&#13;&#10;use the read method to get this time&#13;&#10;&#13;&#10;via the write method, the time can &#13;&#10;be reset"/>
		<Server Name="BgDelay" GUID="{A76EEFFD-5850-473E-9600-A4727D5F8DC5}" Visualized="true" Initialize="true" DefValue="200" WriteProtected="false" Retentive="false" Comment="the delay time for the background &#13;&#10;task can be set here [µs]"/>
		<Server Name="ClassSvr" GUID="{FB3596AC-E2DB-4120-82DB-E715A14AA554}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="CyDelay" GUID="{C9B6C842-FC33-4922-B009-FD657A6E45DA}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="false" Comment="the delay time for the cyclic task &#13;&#10;can be set here [µs]"/>
		<Server Name="MaxBgTime" GUID="{4CE3A88A-0F45-43A3-81C8-91244B5C0FC3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="the maximal time that is needed for&#13;&#10;background is shown here [µs]&#13;&#10;&#13;&#10;use the read method to get this time&#13;&#10;&#13;&#10;via the write method, the time can &#13;&#10;be reset"/>
		<Server Name="MaxCyTime" GUID="{6346291A-4C41-42C3-AD4B-052023D569E2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="the maximal time that is needed for&#13;&#10;the cyclic task is shown here [µs]&#13;&#10;&#13;&#10;use the read method to get this time&#13;&#10;&#13;&#10;via the write method, the time can &#13;&#10;be reset"/>
		<Server Name="MaxRtTime" GUID="{E2A37E78-ECDC-456C-9D00-DEF482DDB7FE}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="the maximal time that is needed for&#13;&#10;the realtime task is shown here [µs]&#13;&#10;&#13;&#10;use the read method to get this time&#13;&#10;&#13;&#10;via the write method, the time can &#13;&#10;be reset"/>
		<Server Name="RtDelay" GUID="{3334AAB9-7686-47DE-826D-BBDF51485AAA}" Visualized="true" Initialize="true" DefValue="300" WriteProtected="false" Retentive="false" Comment="the delay time for the realtime task &#13;&#10;can be set here [µs]"/>
		<Client Name="EnableBgLoad" Required="false" Internal="false" Comment="if this client gets set to 1, the &#13;&#10;workload of Background Task gets&#13;&#10;started"/>
		<Client Name="EnableCyLoad" Required="false" Internal="false" Comment="if this client gets set to 1, the &#13;&#10;workload of Cyclic Task gets&#13;&#10;started"/>
		<Client Name="EnableRtLoad" Required="false" Internal="false" Comment="if this client gets set to 1, the &#13;&#10;workload of Realtime Task gets&#13;&#10;started"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="ObeChr"/>
		<Dokumentation Revision="1.3" Date="2018-04-04" Author="FurLuk" Company="Sigmatek" Description="correction of comments (englisch) and using rules of programming (changing Server names)"/>
		<Dokumentation Revision="1.2" Date="2017-10-19" Author="OC1710198" Company="Sigmatek" Description="Aktuelle Durchlaufzeit + maximale Durchlaufzeit wird nun in der jeweiligen Read-Methode ausgegeben. Dadurch können die Tasks der Klasse entfallen."/>
		<Dokumentation Revision="1.1" Date="2016-09-27" Author="ObeChr" Company="Sigmatek" Description="Simulation der Auslastung kann über Clients aktiviert werden."/>
		<Dokumentation Revision="1.0" Date="2015-02-10" Author="ObeChr" Company="Sigmatek" Description="Erste Version der Klasse zum Belasten der Tasks (Realtime, Cyclic, Background) mit einer definierten Zeit."/>
	</RevDoku>
</Class>
*)
_LoadSimulator : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	RtDelay 	: SvrCh_UDINT;
	ActRtTime 	: SvrCh_UDINT;
	MaxRtTime 	: SvrCh_UDINT;
	CyDelay 	: SvrCh_UDINT;
	ActCyTime 	: SvrCh_UDINT;
	MaxCyTime 	: SvrCh_UDINT;
	BgDelay 	: SvrCh_UDINT;
	ActBgTime 	: SvrCh_UDINT;
	MaxBgTime 	: SvrCh_UDINT;
  //Clients:
	EnableRtLoad 	: CltCh_DINT;
	EnableCyLoad 	: CltCh_DINT;
	EnableBgLoad 	: CltCh_DINT;
  //Variables:
  //Functions:
				//! <Function Comment="the delay of the cyclic task is done &#13;&#10;here" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="the delay of the realtime task is done &#13;&#10;here" Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="the delay of the background task is&#13;&#10;done here" Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActRtTime::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActRtTime::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxRtTime::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxRtTime::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActCyTime::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActCyTime::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxCyTime::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxCyTime::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActBgTime::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActBgTime::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxBgTime::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxBgTime::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _LoadSimulator::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__LOADSIMULATOR
1$UINT, 3$UINT, (SIZEOF(::_LoadSimulator))$UINT, 
10$UINT, 3$UINT, 0$UINT, 
TO_UDINT(1719345518), "_LoadSimulator", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_LoadSimulator.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_LoadSimulator.RtDelay.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1037424695), "RtDelay", 
(::_LoadSimulator.ActRtTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2885181786), "ActRtTime", 
(::_LoadSimulator.MaxRtTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3360292679), "MaxRtTime", 
(::_LoadSimulator.CyDelay.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1088576659), "CyDelay", 
(::_LoadSimulator.ActCyTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2615309525), "ActCyTime", 
(::_LoadSimulator.MaxCyTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4166249160), "MaxCyTime", 
(::_LoadSimulator.BgDelay.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3746116812), "BgDelay", 
(::_LoadSimulator.ActBgTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2406387347), "ActBgTime", 
(::_LoadSimulator.MaxBgTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3974041742), "MaxBgTime", 
//Clients:
(::_LoadSimulator.EnableRtLoad.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3467335), "EnableRtLoad", 
(::_LoadSimulator.EnableCyLoad.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(808385992), "EnableCyLoad", 
(::_LoadSimulator.EnableBgLoad.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(614598542), "EnableBgLoad", 
END_FUNCTION


#define USER_CNT__LoadSimulator 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__LoadSimulator] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _LoadSimulator::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__LoadSimulator, pCmd := #vmt.CmdTable);
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RtDelay.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF RtDelay.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActRtTime.pMeth			:= StoreMethod( #ActRtTime::Read(), #ActRtTime::Write() );
	IF ActRtTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxRtTime.pMeth			:= StoreMethod( #MaxRtTime::Read(), #MaxRtTime::Write() );
	IF MaxRtTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CyDelay.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF CyDelay.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActCyTime.pMeth			:= StoreMethod( #ActCyTime::Read(), #ActCyTime::Write() );
	IF ActCyTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxCyTime.pMeth			:= StoreMethod( #MaxCyTime::Read(), #MaxCyTime::Write() );
	IF MaxCyTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BgDelay.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF BgDelay.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ActBgTime.pMeth			:= StoreMethod( #ActBgTime::Read(), #ActBgTime::Write() );
	IF ActBgTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxBgTime.pMeth			:= StoreMethod( #MaxBgTime::Read(), #MaxBgTime::Write() );
	IF MaxBgTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	tmpTimeStart  : UDINT;
    tmpTimeEnd    : UDINT;
  END_VAR

  EnableRtLoad := EnableRtLoad.Read();
  
  // check if the simulation for realtime task is active
  if (EnableRtLoad) then
  
    // get start time of delay
    tmpTimeStart  := OS_READMICROSEC();
    tmpTimeEnd    := tmpTimeStart;
    
    // wait until delay time has passed
    while ((tmpTimeEnd - tmpTimeStart) < RtDelay) do
      
      // get the actual time for comparing
      tmpTimeEnd := OS_READMICROSEC();
      
    end_while;
  
  end_if;
  
	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	tmpTimeStart  : UDINT;
    tmpTimeEnd    : UDINT;
  END_VAR

  EnableCyLoad := EnableCyLoad.Read();
  
  // check if the simulation for cyclic task is active
  if (EnableCyLoad) then

    // get start time of delay
    tmpTimeStart  := OS_READMICROSEC();
    tmpTimeEnd    := tmpTimeStart;
    
    // wait until delay time has passed
    while ((tmpTimeEnd - tmpTimeStart) < CyDelay) do
      
      // get actual time for comparing
      tmpTimeEnd := OS_READMICROSEC();
      
    end_while;
  
  end_if;
    
	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	tmpTimeStart  : UDINT;
    tmpTimeEnd    : UDINT;
  END_VAR

  EnableBgLoad := EnableBgLoad.Read();
  
  // check if the simulation for background task is active
  if (EnableBgLoad) then

    // get start time of delay
    tmpTimeStart  := OS_READMICROSEC();
    tmpTimeEnd    := tmpTimeStart;
    
    // wait until delay time has passed
    while ((tmpTimeEnd - tmpTimeStart) < BgDelay) do
      
      // get actual time for comparing
      tmpTimeEnd := OS_READMICROSEC();
      
    end_while;

  end_if;
    
	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::ActRtTime::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  // reset actual time 
  _RealAverageTime := 0;

	result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::MaxRtTime::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  // reset maximal time 
  _RealMaximumTime := 0;

	result := input;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::ActCyTime::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  // reset actual time 
  _CyclicAverageTime := 0;

	result := input;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::MaxCyTime::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  // reset maximal time 
  _CyclicMaximumTime := 0;

	result := input;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::ActBgTime::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  // reset actual time 
  _BackgroundAverageTime := 0;

	result := input;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::MaxBgTime::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  // reset maximal time 
  _BackgroundMaximumTime := 0;

	result := input;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::ActRtTime::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

  ActRtTime := _RealAverageTime;
	output := ActRtTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::MaxRtTime::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR
  
  MaxRtTime := _RealMaximumTime;  
	output := MaxRtTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::ActCyTime::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR
  
  ActCyTime := _CyclicAverageTime;
	output := ActCyTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::MaxCyTime::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR
  
  MaxCyTime := _CyclicMaximumTime;
	output := MaxCyTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::ActBgTime::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

  ActBgTime := _BackgroundAverageTime;
	output := ActBgTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _LoadSimulator::MaxBgTime::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

  MaxBgTime := _BackgroundMaximumTime;  
	output := MaxBgTime;

END_FUNCTION
