//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_PW022                     1089
// address offsets for SDO communication
#define PW022_ADDR_CFG_MODUL                16#004
// timeouts
#define PW022_SDO_RESPONSE_TIMEOUT          SDIAS_SDO_TIMEOUT * 2
#define PW022_MIN_PERIODE_TIME              100  //minimal allowed periode time * 500nsec
#define PW022_MAX_PERCENT                 10000  //maximal value for percent (100.00)
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "PW022"
	Revision           = "1.5"
	GUID               = "{0A1403D2-8490-4150-9E1E-C614C426BB4E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(656,120)"
	Comment            = "SDIAS pwm output module&#13;&#10;2x 24V DC / 1A PWM&#13;&#10;">
	<Channels>
		<Server Name="ClassState">
		</Server>
		<Server Name="PeriodeDuration_Ch1" GUID="{2027AF97-1B39-41B5-8B8E-CE18BAA9D66D}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="false" Comment="Set Period duration time of PWM (channels 1-2).&#13;&#10;PWMUnitMode = 0 .. set periode time in 1 탎ec steps. Minimal value is 50 * 1탎ecs (equal to 20khz)&#13;&#10;PWMUnitMode = 1 .. set periode time in 500nsec steps. Minimal value is 100 * 500nsecs (equal to 20khz).&#13;&#10;"/>
		<Server Name="PeriodeDuration_Ch2" GUID="{8B790A62-5BB9-4F53-81E5-48E9C6CDEB77}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="false" Comment="Set Period duration time of PWM (channels 1-2).&#13;&#10;PWMUnitMode = 0 .. set periode time in 1 탎ec steps. Minimal value is 50 * 1탎ecs (equal to 20khz)&#13;&#10;PWMUnitMode = 1 .. set periode time in 500nsec steps. Minimal value is 100 * 500nsecs (equal to 20khz).&#13;&#10;"/>
		<Server Name="PWMOnTime_Ch1" GUID="{0070F06B-2531-4BC5-9D69-D11A141168D7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set pwm ontime of corresponding channel to according setting of PWMOnTimeMode&#13;&#10;The pwm ontime can not be greater than the PeriodeDuration_PWM time.&#13;&#10;PWMUnitMode = 0 .. set ontime in percent from 0 to 10000 (100.00%) steps.&#13;&#10;PWMUnitMode = 1 .. set ontime in 500nsec steps (must be smaller than periode duration). "/>
		<Server Name="PWMOnTime_Ch2" GUID="{680906BC-5A76-4412-A613-EC9407B0C396}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set pwm ontime of corresponding channel to according setting of PWMOnTimeMode&#13;&#10;The pwm ontime can not be greater than the PeriodeDuration_PWM time.&#13;&#10;PWMOnTimeMode = 0 .. set ontime in percent from 0 to 10000 (100.00%) steps.&#13;&#10;PWMOnTimeMode = 1 .. set ontime in 500nsec steps (must be smaller than periode duration). "/>
		<Server Name="StatusBits" GUID="{98958E00-1358-4990-8372-F1FAFE62A4B3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="status and error bits of the 킗.&#13;&#10;See type &quot;t_ReadStatus_uC&quot; for further description."/>
		<Server Name="VoltageOk" GUID="{F2AD1F46-C504-463B-AAAE-0823A8697169}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of +24V supply for outputs 1 - 4.&#13;&#10;0 ... +24V missing&#13;&#10;1 ... +24V Ok"/>
		<Client Name="PWMUnitMode" Required="true" Internal="false" DefValue="0" Comment="Set the pwm ontime mode as initvalue.&#13;&#10;0 .. set ontime value in percent from 0 up to 10000 (100.00%) of periodetime and&#13;&#10;periode time in 1탎ec steps (default) &#13;&#10;1 .. set ontime value and periode time in 500ns steps. "/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="PieSte"/>
		<Dokumentation Revision="1.5" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.4" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.3" Date="24.10.2018" Author="PieSte" Company="Sigmatek" Description="Corrected a bug where the timestamp in the InitModule() for the SDO timeout check is not set.&#13;&#10;Add numbers for the assignment of the log messages."/>
		<Dokumentation Revision="1.2" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.1" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.0" Date="20.12.2017" Author="PieSte" Company="Sigmatek" Description="First library version."/>
	</RevDoku>
	<Network Name="PW022">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{D9B58771-817D-410A-ACFA-11533B26B3CE}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="this.SDOState" Destination="_base.SDOState" Vertices="(804,630),(632,630),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

PW022 : CLASS
: SdiasBase
	TYPE
	  t_uC_StatusBits : BSINT  //! <Type Comment="Status bits of one uC" Name="t_uC_StatusBits"/>
	  [
	    1 OverCurrent7A,
	    2 OverCurrent14A,
	    3 DC_Ok,
	    4 PeripheryReset,
	    5 VoltageTooHigh,
	  ];
#pragma pack(push, 1)
	  t_ReadData : STRUCT  //! <Type Public="true" Comment="data structure for status bits of the two uC" Name="t_ReadData"/>
	    Status : t_uC_StatusBits;  //! <Type Comment="Status bits of uC1" Name="t_ReadData.Status"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_WriteData : STRUCT
	    uiOnTimeCh1 : UINT;
	    uiOnTimeCh2 : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_Accesses : STRUCT
	    pReadData : ^t_ReadData;
	    pWriteData : ^t_WriteData;
	    sWriteData : t_WriteData;
	  END_STRUCT;
#pragma pack(pop)
	  t_InitSSW :
	  (
	    _InitVariables,
	    _ConfigModule,
	    _Finish,
	    _InitError
	  )$UDINT;
#pragma pack(push, 1)
	  t_OutputConfig : STRUCT
	    PeriodeTimeCh1 : UINT;
	    PeriodeTimeCh2 : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
	  t_SendSDO_SSW :
	  (
	    _SDO_Idle,
	    _SDO_SendConfig,
	    _SDO_Error
	  )$UDINT;
#pragma pack(push, 1)
	  t_uC_StatusServer : STRUCT  //! <Type Public="true" Name="t_uC_StatusServer"/>
	    Status_uC : t_uC_StatusBits;
	    bsReserved : BSINT
	    [
	      1 Bit1,
	      2 Bit2,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	    biReserved : BINT
	    [
	      1 Bit1,
	      2 Bit2,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	      9 Bit9,
	      10 Bit10,
	      11 Bit11,
	      12 Bit12,
	      13 Bit13,
	      14 Bit14,
	      15 Bit15,
	      16 Bit16,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	StatusBits 	: SvrCh_t_uC_StatusServer_PTofCls_PW022;
	PeriodeDuration_Ch1 	: SvrCh_DINT;
	PWMOnTime_Ch1 	: SvrCh_DINT;
	PeriodeDuration_Ch2 	: SvrCh_DINT;
	PWMOnTime_Ch2 	: SvrCh_DINT;
	VoltageOk 	: SvrCh_DINT;
  //Clients:
	PWMUnitMode 	: CltCh_DINT;
  //Variables:
		sAccesses 	: t_Accesses;
		eInitSSW 	: t_InitSSW;
		eInitSSWErrorStep 	: t_InitSSW;
		eSDO_SSW 	: t_SendSDO_SSW;
		eResponseState 	: t_ResponseState;
		udSDOTimeout 	: UDINT;
		bsChangedConfig : BSINT
		[
		  1 SDO_SendConfig,
		];

		sConfigPeriodeTime 	: t_OutputConfig;
		usPeriodeTimeMulti 	: USINT;
  //Functions:
				//! <Function Comment="Init-Methode of Class.&#13;&#10;&#13;&#10;This Methode needs to get called. In case the Methode gets overwritten, a call needs to bet installed." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
				//! <Function Name="ClassState.NewInst" Hidden="true"/>
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL PeriodeDuration_Ch1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL PWMOnTime_Ch1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL PeriodeDuration_Ch2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL PWMOnTime_Ch2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB PW022::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_PW022
1$UINT, 5$UINT, (SIZEOF(::PW022))$UINT, 
6$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2837966764), "PW022", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::PW022.StatusBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3987331112), "StatusBits", 
(::PW022.PeriodeDuration_Ch1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(245743511), "PeriodeDuration_Ch1", 
(::PW022.PWMOnTime_Ch1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2177300583), "PWMOnTime_Ch1", 
(::PW022.PeriodeDuration_Ch2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2544692781), "PeriodeDuration_Ch2", 
(::PW022.PWMOnTime_Ch2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(416262621), "PWMOnTime_Ch2", 
(::PW022.VoltageOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2158378107), "VoltageOk", 
//Clients:
(::PW022.PWMUnitMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(184656259), "PWMUnitMode", 
END_FUNCTION


#define USER_CNT_PW022 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_PW022] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION PW022::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_PW022;
	vmt.CmdTable.NewInstr		:= #ClassState::NewInst();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PeriodeDuration_Ch1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #PeriodeDuration_Ch1::Write() );
	IF PeriodeDuration_Ch1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PWMOnTime_Ch1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #PWMOnTime_Ch1::Write() );
	IF PWMOnTime_Ch1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PeriodeDuration_Ch2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #PeriodeDuration_Ch2::Write() );
	IF PeriodeDuration_Ch2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PWMOnTime_Ch2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #PWMOnTime_Ch2::Write() );
	IF PWMOnTime_Ch2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//{{LSL_HIDDEN_FUNCTION
FUNCTION VIRTUAL GLOBAL PW022::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
		ret_code := SdiasBase::ClassState.NewInst(pPara, pResult);
END_FUNCTION
//}}LSL_HIDDEN_FUNCTION
FUNCTION VIRTUAL GLOBAL PW022::Init
  //call baseclass
  SdiasBase::Init();
  
  if _FirstScan then
    //initialize multiplier for unitconverter to avoid division by zero error.
    usPeriodeTimeMulti := 1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::UpdateRt

  // show status at server
  StatusBits.Status_uC := sAccesses.pReadData^.Status;
  
  // show DC ok at servers
  VoltageOk := StatusBits.Status_uC.DC_Ok;      

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::UpdateRtPostScan

  sAccesses.pWriteData^ := sAccesses.sWriteData;   

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::UpdateCy
  VAR
  	TmpRetcode    : iprStates;
  END_VAR

  case eSDO_SSW of
    //**********************************************************************************************************************************************************
    _SDO_Idle:        
      if bsChangedConfig.SDO_SendConfig = TRUE then
        bsChangedConfig.SDO_SendConfig := FALSE;
        // send the config
        eSDO_SSW        := _SDO_SendConfig;
        eResponseState  := _idle;          
      end_if;
    
    //**********************************************************************************************************************************************************
    _SDO_SendConfig:
      case eResponseState of
        _idle:  
          TmpRetcode  := StartWriteSDO(hOffset:=PW022_ADDR_CFG_MODUL, usLength:=sizeof(sConfigPeriodeTime), pWriteBuffer:=(#sConfigPeriodeTime)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout := ops.tAbsolute;
            eResponseState := _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@010C (PW022::UpDateCy) Failed to add write SDO for firmware configuration");
            eSDO_SSW := _SDO_Error;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > PW022_SDO_RESPONSE_TIMEOUT) then
            LogError("@010D (PW022::UpDateCy) SDO Response timeout for configuration");
            eSDO_SSW := _SDO_Error;
          end_if;

        //*****************************************************
        _valid:
          // finished, go back to idle
          eSDO_SSW        := _SDO_Idle;  
          eResponseState  := _idle;
        //*****************************************************
      end_case;
      
    //**********************************************************************************************************************************************************
    _SDO_Error:
      // stay in error step
      // show on server and reset to idle
      SDOState := ERROR;
      eSDO_SSW := _SDO_Idle;
      
  //**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::ConnectEvent

  // start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.ReadAccess.pControlByte then
    sAccesses.pReadData := DefaultAccesses.ReadAccess.pData$^t_ReadData;
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  if DefaultAccesses.WriteAccess.pControlByte then
    sAccesses.pWriteData := DefaultAccesses.WriteAccess.pData$^t_WriteData;
    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  // init steps for initialisation
  eInitSSW := _InitVariables;
  eSDO_SSW := _SDO_Idle;
  eResponseState := _idle;
  eInitState     := _NotInitialized;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode    : iprStates;
  END_VAR
  
  eModuleInitState := BUSY;

  case eInitSSW of
    //**********************************************************************************************************************************************************
    _InitVariables:            
      //--------------------------------------
      // prepare data for outputconfig sdo
      //--------------------------------------
      PWMUnitMode := PWMUnitMode.Read() <> 0;
      if PWMUnitMode = 0 then
        usPeriodeTimeMulti := 2;
      else
        usPeriodeTimeMulti := 1;
      end_if;

      PeriodeDuration_Ch1.Write(input:=PeriodeDuration_Ch1);
      PeriodeDuration_Ch2.Write(input:=PeriodeDuration_Ch2);
      // data is sent now, no need to send it in cyclic again
      bsChangedConfig.SDO_SendConfig := FALSE;      
      eInitSSW := _ConfigModule;
      
    //**********************************************************************************************************************************************************
    _ConfigModule:
      case eResponseState of
        _idle:        
          TmpRetcode  := StartWriteSDO(hOffset:=PW022_ADDR_CFG_MODUL, usLength:=sizeof(sConfigPeriodeTime), pWriteBuffer:=(#sConfigPeriodeTime)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);          
          
          if TmpRetcode = READY then
            udSDOTimeout   := ops.tAbsolute;
            eResponseState := _wait; 
          elsif TmpRetcode = ERROR then
            LogError("@010C (PW022::UpDateCy) Failed to add write SDO for firmware configuration");
            eInitState       := _NoMem;
            eModuleInitState := ERROR;
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
          
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > PW022_SDO_RESPONSE_TIMEOUT) then
            LogError("@010D (PW022::UpDateCy) SDO Response timeout for configuration");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;

        //*****************************************************
        _valid:
          // finished, go to next step
          eInitSSW      := _Finish;    
          eResponseState  := _idle;
      //*****************************************************
      end_case;      
        
//**********************************************************************************************************************************************************
    _Finish:
      // stay in finish, so i can see in the response function if the SDO was started from init or user request      
      eModuleInitState := READY;
      eInitState      := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      eInitState      := _ClientNotready;
      
//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION VIRTUAL PW022::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);

  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;

  if eResult = READY then    
    case eCommand of
    //**********************************************************************
      SDIAS_SDO_CMD_MEM_WRITE:
        case (hOffset) of
        //-------------------------------------------------------------
          PW022_ADDR_CFG_MODUL:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;           
        end_case;
        
    //**********************************************************************
      SDIAS_SDO_CMD_READ_UC_RAM:
        // copy data to local memory

    end_case;
    
    if eResponseState <> _valid then
      LogError("@00E7 (PW022::ReceiveSDOResponse) Error in response data of SDO");
      if eInitSSW = _Finish then
        // error at user SDO
        eSDO_SSW := _SDO_Error;
      else
        // error was at initialisation
        eInitSSW := _InitError;
      end_if;
    end_if;
    
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@00E8 (PW022::ReceiveSDOResponse) Error while writing the firmware configuration");
    end_case;
    
    if eInitSSW = _Finish then
      // error at user SDO
      eSDO_SSW := _SDO_Error;
    else
      // error was at initialisation
      eInitSSW := _InitError;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL PW022::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE or SDIAS_TASK_MASK_RT_POST or SDIAS_TASK_MASK_CY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR

	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_PW022 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;

END_FUNCTION


FUNCTION VIRTUAL PW022::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR

 //Overwrite in derived Classes
  output := DEVICE_ID_PW022;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::PWMOnTime_Ch1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	dTmpPercentValue : DINT;
  END_VAR
  
  if PWMUnitMode = 0 then
    if input > PW022_MAX_PERCENT then
      input := PW022_MAX_PERCENT;
    elsif input < 0 then
      input := 0;
    end_if;  
    //round value up
    dTmpPercentValue := (((input*sConfigPeriodeTime.PeriodeTimeCh1*10)/PW022_MAX_PERCENT)+5)/10;
    sAccesses.sWriteData.uiOnTimeCh1 := dTmpPercentValue$UINT;
  else  
    if input > PeriodeDuration_Ch1 then
      //set to maximum pwm ontime
      input := PeriodeDuration_Ch1;
    elsif input < 0 then
      input := 0;
    end_if; 
    sAccesses.sWriteData.uiOnTimeCh1 := input$UINT;
  end_if;
  
  PWMOnTime_Ch1 := input;    
  result := PWMOnTime_Ch1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::PWMOnTime_Ch2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	dTmpPercentValue : DINT;
  END_VAR

  if PWMUnitMode = 0 then
    if input > PW022_MAX_PERCENT then
      input := PW022_MAX_PERCENT;
    elsif input < 0 then
      input := 0;
    end_if;
    //round value up
    dTmpPercentValue := (((input*sConfigPeriodeTime.PeriodeTimeCh2*10)/PW022_MAX_PERCENT)+5)/10;
    sAccesses.sWriteData.uiOnTimeCh2 := dTmpPercentValue$UINT;
  else  
    if input > PeriodeDuration_Ch2 then
      //set to maximum pwm ontime
      input := PeriodeDuration_Ch2;
    elsif input < 0 then
      input := 0;
    end_if; 
    sAccesses.sWriteData.uiOnTimeCh2 := input$UINT;
  end_if;
  
  PWMOnTime_Ch2 := input;    
  result := PWMOnTime_Ch2;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::PeriodeDuration_Ch1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input > 0xFFFF then
    input := 0xFFFF;
  elsif input < (PW022_MIN_PERIODE_TIME/usPeriodeTimeMulti) then
    input := PW022_MIN_PERIODE_TIME/usPeriodeTimeMulti;    
  end_if;

	PeriodeDuration_Ch1 := input;
  if sConfigPeriodeTime.PeriodeTimeCh1 <> (PeriodeDuration_Ch1$UINT*usPeriodeTimeMulti) then
    sConfigPeriodeTime.PeriodeTimeCh1 := PeriodeDuration_Ch1$UINT*usPeriodeTimeMulti;
    // start SDO-transfer in cyclic
    bsChangedConfig.SDO_SendConfig := TRUE;
  end_if;
	result := PeriodeDuration_Ch1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PW022::PeriodeDuration_Ch2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input > 0xFFFF then
    input := 0xFFFF;
  elsif input < (PW022_MIN_PERIODE_TIME/usPeriodeTimeMulti) then
    input := PW022_MIN_PERIODE_TIME/usPeriodeTimeMulti;    
  end_if;

	PeriodeDuration_Ch2 := input;
  if sConfigPeriodeTime.PeriodeTimeCh2 <> (PeriodeDuration_Ch2$UINT*usPeriodeTimeMulti) then
    sConfigPeriodeTime.PeriodeTimeCh2 := PeriodeDuration_Ch2$UINT*usPeriodeTimeMulti;
    // start SDO-transfer in cyclic
    bsChangedConfig.SDO_SendConfig := TRUE;  
  end_if;
	result := PeriodeDuration_Ch2;

END_FUNCTION