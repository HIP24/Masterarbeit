//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
////FPGA Components
#define CP841_IOS_DEVICE_ID_CPU_REG        16#0F02

//CPU Register
#define CP841_IOS_OFFSET_DIGITAL_INPUT_REGISTER           16#00
#define CP841_IOS_OFFSET_DIGITAL_OUTPUT_CLEAR_REGISTER    16#01
#define CP841_IOS_OFFSET_DIGITAL_OUTPUT_READ_SET_REGISTER 16#02

#define CP841_IOS_REGISTER_NOT_FOUND       16#FFFF

#define CP841_REQ_SYSINFO_VERSION           0x20000
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Source\interfaces\lsl_st_pci.h"
#include "..\..\Source\interfaces\lsl_st_xadc.h"
#include "..\..\Class\PLC_Info\XRegs.h"
#include "..\..\Source\interfaces\lsl_st_gpio.h"
#include "..\..\Source\interfaces\lsl_st_sensor_types.h"
#include "..\..\Source\interfaces\lsl_st_sysinfo.h"

(*!
<Class
	Name               = "CP841_IOs"
	Revision           = "1.2"
	GUID               = "{40794CEE-13B3-4A6D-83BD-46EB39053DBD}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\DigInOut.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(688,120)"
	Comment            = "Hardwareclass to access the IOs on the CP841.">
	<Channels>
		<Server Name="BatteryOk" GUID="{9B50E2F1-78B4-446F-B111-2A8650254702}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the battery.&#13;&#10;0 .. Not OK&#13;&#10;1 .. OK"/>
		<Server Name="Can1_Termination" GUID="{AC47D6E9-FF5E-4EEC-9E56-357CDBFD60DD}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Write to this server to set the CAN termination.&#13;&#10;0 ... CAN termination is off&#13;&#10;1 ... CAN termination is on&#13;&#10;-1 ... not available/failed to set register in FPGA"/>
		<Server Name="CAN_1_Connect" GUID="{1C34BD3D-3399-4322-B991-8F4A77EB89F1}" Class="_CanLib" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connection servers for Hardware-Editor."/>
		<Server Name="ClassState" GUID="{9F202EFE-EE21-4E44-B7F9-5F35338F176D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the initialisation state of the class.&#13;&#10; 0 ... Initialisation ok&#13;&#10;-3 ... &quot;IXREGS&quot; interface not found&#13;&#10;-4 ... &quot;GPIO&quot; interface not found&#13;&#10;-7 ... &quot;LSL_SYSINFO&quot; interface not found&#13;&#10;&#13;&#10;-1X ... Failed to fetch handle for X&#13;&#10;-2X ... Failed to fetch scaling info for X&#13;&#10;-3X ... Failed to calculate scaling factors for X&#13;&#10;&#13;&#10;X:&#13;&#10;0 ... SupplyVoltage&#13;&#10;1 ... TemperatureFPGACore&#13;&#10;2 ... TemperatureConnectors&#13;&#10;3 ... TemperatureCPUBoard&#13;&#10;4 ... TemperatureCPUCore0&#13;&#10;5 ... TemperatureCPUCore1&#13;&#10;6 ... TemperatureCPUCore2&#13;&#10;7 ... TemperatureCPUCore3"/>
		<Server Name="ErrorLED" GUID="{448A902C-4DEC-40EB-BB71-3BAC89D1AE8C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="The &quot;Error&quot;-LED of the CPU can be controlled with this server.&#13;&#10;&#13;&#10;0 ... HW - Status of LED is active&#13;&#10;1 ... LED is off&#13;&#10;2 ... LED is flashes&#13;&#10;3 ... LED is on&#13;&#10;&#13;&#10;-1 ... Class not ok"/>
		<Server Name="Ethernet_1_Connect" GUID="{5EDFEC2F-1E9F-4338-9D1F-26A2E01D758E}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connection servers for Hardware-Editor."/>
		<Server Name="Ethernet_2_Connect" GUID="{9F570990-8DE0-4FEF-AF1F-3A3D5CECDDE6}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connection servers for Hardware-Editor."/>
		<Server Name="RunLED" GUID="{A89DA939-3B97-4E24-8489-CCCFE6594518}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="The &quot;Run&quot;-LED of the CPU can be controlled with this server.&#13;&#10;&#13;&#10;0 ... HW - Status of LED is active&#13;&#10;1 ... LED is off&#13;&#10;2 ... LED is flashes&#13;&#10;3 ... LED is on&#13;&#10;&#13;&#10;-1 ... Class not ok"/>
		<Server Name="StatusLED" GUID="{0CEBACF2-E190-4C91-95AC-3A8BAC9018E1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="The &quot;Status&quot;-LED of the CPU can be controlled with this server.&#13;&#10;&#13;&#10;0 ... HW - Status of LED is active&#13;&#10;1 ... LED is off&#13;&#10;2 ... LED is flashes&#13;&#10;3 ... LED is on&#13;&#10;&#13;&#10;-1 ... Class not ok"/>
		<Server Name="SupplyVoltage" GUID="{CF5C95CB-991E-4AF0-A003-7C833B8508E7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the supply voltage in mV."/>
		<Server Name="TemperatureConnectors" GUID="{5A28B7AE-CAAD-4661-B49D-75D5119626A6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured ambient temperature of the connectors in [1°C/10]."/>
		<Server Name="TemperatureCPUBoard" GUID="{94EF90F6-F4C6-492F-8B8B-E623730C43BC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured ambient temperature of the CPU board in [1°C/10]."/>
		<Server Name="TemperatureCPUCore0" GUID="{0CB193A5-A82B-4910-8715-06BB395E080B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured core 0 temperature of the CPU in [1°C/10]."/>
		<Server Name="TemperatureCPUCore1" GUID="{EB6118C9-1631-427E-896C-0325C358CF25}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured core 1 temperature of the CPU in [1°C/10]."/>
		<Server Name="TemperatureCPUCore2" GUID="{77BE16CD-5145-4037-B4BE-31E60DBC0E97}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured core 2 temperature of the CPU in [1°C/10]."/>
		<Server Name="TemperatureCPUCore3" GUID="{3D745545-D817-4988-B0BA-28324D9F991D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured core 3 temperature of the CPU in [1°C/10]."/>
		<Server Name="TemperatureFPGACore" GUID="{CD9EDDAA-73D6-4560-B2B7-4054BCA3780E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured core temperature of the FPGA in [1°C/10]."/>
		<Server Name="USB_1_Connect" GUID="{36180B36-B0C3-4FB8-A127-79F6DCE13C1E}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connection servers for Hardware-Editor."/>
		<Client Name="To_HwControl" Required="true" Internal="false" Comment="Connect this client to the class &quot;HwControl&quot;."/>
		<Client Name="XXXBase_IOs6" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\interfaces\lsl_st_pci.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_xadc.h" Include="true"/>
			<File Path=".\Class\PLC_Info\XRegs.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_gpio.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_sensor_types.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_sysinfo.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="LanSte"/>
		<Dokumentation Revision="1.2" Date="29.01.2024" Author="LanSte" Company="Sigmatek" Description="Fixed an AccessException when the interface version of SYSINFO is to small."/>
		<Dokumentation Revision="1.1" Date="24.07.2023" Author="EisMic" Company="Sigmatek" Description="Added servers for temperature sensors of CPU core 2 and 3."/>
		<Dokumentation Revision="1.0" Date="13.06.2023" Author="LanSte" Company="Sigmatek" Description="Initial version."/>
	</RevDoku>
	<Network Name="CP841_IOs">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "XXXBase_IOs6"
				GUID       = "{B5C0A1F6-2BF6-4F62-905C-5E704A21DE82}"
				Class      = "XXXBase_IOs"
				Position   = "(150,120)"
				Visualized = "false">
				<Channels>
					<Server Name="CAN_1_Connect"/>
					<Server Name="CAN_2_Connect"/>
					<Server Name="ClassState"/>
					<Server Name="COM_1_Connect"/>
					<Server Name="COM_2_Connect"/>
					<Server Name="COM_3_Connect"/>
					<Server Name="Ethernet_1_Connect"/>
					<Server Name="Ethernet_2_Connect"/>
					<Server Name="Ethernet_3_Connect"/>
					<Server Name="Ethernet_4_Connect"/>
					<Server Name="USB_1_Connect"/>
					<Client Name="To_HwControl"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.XXXBase_IOs6" Destination="XXXBase_IOs6.ClassState"/>
			<Connection Source="XXXBase_IOs6.To_HwControl" Destination="this.To_HwControl" Vertices="(150,210),(38,210),"/>
			<Connection Source="this.USB_1_Connect" Destination="XXXBase_IOs6.USB_1_Connect" Vertices="(908,1050),(736,270),"/>
			<Connection Source="this.CAN_1_Connect" Destination="XXXBase_IOs6.CAN_1_Connect" Vertices="(908,1230),(736,570),"/>
			<Connection Source="this.Ethernet_1_Connect" Destination="XXXBase_IOs6.Ethernet_1_Connect" Vertices="(908,1110),(736,330),"/>
			<Connection Source="this.Ethernet_2_Connect" Destination="XXXBase_IOs6.Ethernet_2_Connect" Vertices="(908,1170),(736,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
CP841_IOs : CLASS
	TYPE
	  e_SensorID :
	  (
	    IDVCC,
	    IDTempFPGA,
	    IDTempConn,
	    IDTempCPUBoard,
	    IDTempCPUCore0,
	    IDTempCPUCore1,
	    IDTempCPUCore2,
	    IDTempCPUCore3
	  )$UDINT;
#pragma pack(push, 1)
	  t_Sensor : STRUCT
	    Handle : HDINT;
	    Mul : DINT;
	    Div : DINT;
	    pDst : ^DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassState 	: SvrChCmd_DINT;
	BatteryOk 	: SvrCh_DINT;
	SupplyVoltage 	: SvrCh_DINT;
	TemperatureFPGACore 	: SvrCh_DINT;
	TemperatureConnectors 	: SvrCh_DINT;
	TemperatureCPUBoard 	: SvrCh_DINT;
	TemperatureCPUCore0 	: SvrCh_DINT;
	TemperatureCPUCore1 	: SvrCh_DINT;
	TemperatureCPUCore2 	: SvrCh_DINT;
	TemperatureCPUCore3 	: SvrCh_DINT;
	RunLED 	: SvrCh_DINT;
	ErrorLED 	: SvrCh_DINT;
	StatusLED 	: SvrCh_DINT;
	Can1_Termination 	: SvrCh_DINT;
	USB_1_Connect 	: SvrChCmd_DINT;
	Ethernet_1_Connect 	: SvrChCmd_DINT;
	Ethernet_2_Connect 	: SvrChCmd_DINT;
	CAN_1_Connect 	: SvrChCmd_DINT;
  //Clients:
	To_HwControl 	: CltChCmd_HwControl;
	XXXBase_IOs6 	: CltChCmd_XXXBase_IOs;
  //Variables:
		us_FirstScan 	: USINT;
		p_XREGS 	: ^T_XREGS;
		pGPIO 	: ^LSL_GPIO_TYPE;
		pLSLSysInfo 	: ^LSL_SYSINFO_TYPE;
		bsLedValue : BSINT
		[
		];

		sDigitalOutputReadSetRegisterInfo 	: LSL_LOCALIO_IDINFO;
		sDigitalOutputClearRegisterInfo 	: LSL_LOCALIO_IDINFO;
		udFoundRegisterIndex 	: UDINT;
		aSensors : ARRAY [IDVCC..IDTempCPUCore3] OF t_Sensor;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION CalcMulDiv100m
		VAR_INPUT
			unitfact 	: ESensorUnitFact;
			pSensor 	: ^t_Sensor;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
	
	FUNCTION CalcMulDiv1m
		VAR_INPUT
			unitfact 	: ESensorUnitFact;
			pSensor 	: ^t_Sensor;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RunLED::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorLED::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StatusLED::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Can1_Termination::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL USB_1_Connect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Ethernet_1_Connect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Ethernet_2_Connect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CAN_1_Connect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using XXXBase_IOs
#pragma usingLtd HwControl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CP841_IOs::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CP841_IOS
1$UINT, 2$UINT, (SIZEOF(::CP841_IOs))$UINT, 
18$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2779782445), "CP841_IOs", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::CP841_IOs.ClassState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
(::CP841_IOs.BatteryOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3075126500), "BatteryOk", 
(::CP841_IOs.SupplyVoltage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(54046992), "SupplyVoltage", 
(::CP841_IOs.TemperatureFPGACore.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(859525245), "TemperatureFPGACore", 
(::CP841_IOs.TemperatureConnectors.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2379133219), "TemperatureConnectors", 
(::CP841_IOs.TemperatureCPUBoard.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1160390013), "TemperatureCPUBoard", 
(::CP841_IOs.TemperatureCPUCore0.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(885071959), "TemperatureCPUCore0", 
(::CP841_IOs.TemperatureCPUCore1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1137053889), "TemperatureCPUCore1", 
(::CP841_IOs.TemperatureCPUCore2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3671015803), "TemperatureCPUCore2", 
(::CP841_IOs.TemperatureCPUCore3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2915594733), "TemperatureCPUCore3", 
(::CP841_IOs.RunLED.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4270009735), "RunLED", 
(::CP841_IOs.ErrorLED.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3486187614), "ErrorLED", 
(::CP841_IOs.StatusLED.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2779581079), "StatusLED", 
(::CP841_IOs.Can1_Termination.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2215910728), "Can1_Termination", 
(::CP841_IOs.USB_1_Connect.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4121287287), "USB_1_Connect", 
(::CP841_IOs.Ethernet_1_Connect.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1853777383), "Ethernet_1_Connect", 
(::CP841_IOs.Ethernet_2_Connect.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1475565858), "Ethernet_2_Connect", 
(::CP841_IOs.CAN_1_Connect.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(192824020), "CAN_1_Connect", 
//Clients:
(::CP841_IOs.To_HwControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(1012711711), "To_HwControl", TO_UDINT(2471641665), "HwControl", 5$UINT, 21$UINT, 
(::CP841_IOs.XXXBase_IOs6.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(139628313), "XXXBase_IOs6", TO_UDINT(819479645), "XXXBase_IOs", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_CP841_IOs 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CP841_IOs] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CP841_IOs::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_CP841_IOs, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RunLED.pMeth			:= StoreMethod( #M_RD_DIRECT(), #RunLED::Write() );
	IF RunLED.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorLED.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorLED::Write() );
	IF ErrorLED.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StatusLED.pMeth			:= StoreMethod( #M_RD_DIRECT(), #StatusLED::Write() );
	IF StatusLED.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Can1_Termination.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Can1_Termination::Write() );
	IF Can1_Termination.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, USB_1_Connect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #USB_1_Connect::Read();
	USB_1_Connect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF USB_1_Connect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Ethernet_1_Connect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #Ethernet_1_Connect::Read();
	Ethernet_1_Connect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Ethernet_1_Connect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Ethernet_2_Connect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #Ethernet_2_Connect::Read();
	Ethernet_2_Connect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Ethernet_2_Connect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CAN_1_Connect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #CAN_1_Connect::Read();
	CAN_1_Connect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CAN_1_Connect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL CP841_IOs::Init
  VAR
    result              : DINT;
    tmpLocalIOInfo      : LSL_LOCALIO_IDINFO;
    udAmountLocalIOs    : UDINT;
    i                   : UDINT;
    retval              : DINT;
    sensorinfo          : LSL_SENSOR_VALUE_INFO_TYPE;
    aHandles            : Array [0..15] of HDINT;
    idx                 : e_SensorID;
  END_VAR

  us_FirstScan += 1; //Init-counter
  
  if us_FirstScan = 10 then

    if OS_CILGET("IXREGS", #p_XREGS) <> SYS_ERR_NONE then
      ClassState := -3; //XREGS Device not found
      return;
    end_if;

    if OS_CILGET(INTERFACE_GPIO, #pGPIO) <> SYS_ERR_NONE then
      ClassState := -4; //GPIO Device not found
      return;
    end_if;
    
    if OS_CILGET(INTERFACE_LSL_SYSINFO, #pLSLSysInfo) <> SYS_ERR_NONE then
      pLSLSysInfo := NIL;
      ClassState := -7;
      return;
    end_if;
    if pLSLSysInfo^.version < CP841_REQ_SYSINFO_VERSION then
      ClassState := -7;
      return;
    end_if;
     
    // Get Handles and infos for FPGA Temperatur und Voltage
    //*********************************************************************************************************************
    
    // Voltage Handle
    retval := OS_SYSINFO_GET_PROPEX(pLSLSysInfo, LSL_SYSINFOEX_SENSORS_TYPE_LIST, ESensorTypeVoltage, ESensorSubTypeVoltageVCC, #aSensors[e_SensorID::IDVCC].Handle, sizeof(t_Sensor.Handle));
    if retval <= 0 Then // The reval of LSL_SYSINFOEX_SENSORS_TYPE_LIST contains the number of returned handles
      ClassState := -10;
      return;
    end_if;
    // Info
    retval := OS_SYSINFO_GET_PROPEX(pLSLSysInfo, LSL_SYSINFOEX_SENSORS_INFO_GET, aSensors[e_SensorID::IDVCC].Handle, 0, #sensorinfo, sizeof(sensorinfo));
    if retval <> LSL_SYSINFO_ERR_NONE then
      ClassState := -20;
      return;
    end_if;
    // Calc scaling
    if CalcMulDiv1m(unitfact:=sensorinfo.vi_unitfact$ESensorUnitFact, pSensor:=#aSensors[e_SensorID::IDVCC]) <> 0 then
      ClassState := -30;
      return;
    end_if;
    aSensors[e_SensorID::IDVCC].pDst := #SupplyVoltage.dData;
    
    // Int FPGA Handle
    retval := OS_SYSINFO_GET_PROPEX(pLSLSysInfo, LSL_SYSINFOEX_SENSORS_TYPE_LIST, ESensorTypeTemperature, ESensorSubTypeTemperatureFpgaInternal, #aSensors[e_SensorID::IDTempFPGA].Handle, sizeof(t_Sensor.Handle));
    if retval <= 0 Then // The reval of LSL_SYSINFOEX_SENSORS_TYPE_LIST contains the number of returned handles
      ClassState := -11;
      return;
    end_if;
    aSensors[e_SensorID::IDTempFPGA].pDst := #TemperatureFPGACore.dData;
    
    // 2 ext FPGA Handles
    _memset(dest:=#aHandles[0], usByte:=0, cntr:=sizeof(aHandles));
    retval := OS_SYSINFO_GET_PROPEX(pLSLSysInfo, LSL_SYSINFOEX_SENSORS_TYPE_LIST, ESensorTypeTemperature, ESensorSubTypeTemperatureFpgaExternal, #aHandles[0], sizeof(aHandles));
    if retval >= 2 Then // The reval of LSL_SYSINFOEX_SENSORS_TYPE_LIST contains the number of returned handles
      
      aSensors[e_SensorID::IDTempConn].Handle     := aHandles[0];
      aSensors[e_SensorID::IDTempConn].pDst       := #TemperatureConnectors.dData;
      
      aSensors[e_SensorID::IDTempCPUBoard].Handle := aHandles[1];
      aSensors[e_SensorID::IDTempCPUBoard].pDst   := #TemperatureCPUBoard.dData;
    
    else
      ClassState := -12;
      return;
    end_if;
    
    // 4 CPU Core Handles
    _memset(dest:=#aHandles[0], usByte:=0, cntr:=sizeof(aHandles));
    retval := OS_SYSINFO_GET_PROPEX(pLSLSysInfo, LSL_SYSINFOEX_SENSORS_TYPE_LIST, ESensorTypeTemperature, ESensorSubTypeTemperatureCpu, #aHandles[0], sizeof(aHandles));
    if retval >= 4 Then // The reval of LSL_SYSINFOEX_SENSORS_TYPE_LIST contains the number of returned handles
      
      aSensors[e_SensorID::IDTempCPUCore0].Handle := aHandles[0];
      aSensors[e_SensorID::IDTempCPUCore0].pDst   := #TemperatureCPUCore0.dData;
      
      aSensors[e_SensorID::IDTempCPUCore1].Handle := aHandles[1];
      aSensors[e_SensorID::IDTempCPUCore1].pDst   := #TemperatureCPUCore1.dData;

      aSensors[e_SensorID::IDTempCPUCore2].Handle := aHandles[2];
      aSensors[e_SensorID::IDTempCPUCore2].pDst   := #TemperatureCPUCore2.dData;

      aSensors[e_SensorID::IDTempCPUCore3].Handle := aHandles[3];
      aSensors[e_SensorID::IDTempCPUCore3].pDst   := #TemperatureCPUCore3.dData;
    
    else
      ClassState := -14;
      return;
    end_if;
    
    // Calc scaling fall all temperatur sensors (VCC excluded because that uses a different scaling.)
    for idx$UDINT := e_SensorID::IDTempFPGA$UDINT to e_SensorID::IDTempCPUCore3$UDINT do
      
      // Info
      retval := OS_SYSINFO_GET_PROPEX(pLSLSysInfo, LSL_SYSINFOEX_SENSORS_INFO_GET, aSensors[idx].Handle, 0, #sensorinfo, sizeof(sensorinfo));
      if retval <> LSL_SYSINFO_ERR_NONE then
        ClassState := -20 - idx$DINT;  // -21 to -27
        return;
      end_if;
      
      // Calc scaling
      CalcMulDiv100m(unitfact:=sensorinfo.vi_unitfact$ESensorUnitFact, pSensor:=#aSensors[idx]);
      if retval <> 0 then
        ClassState := -30 - idx$DINT;  // -31 to -37
        return;
      end_if;
      
    end_for;
    
    //Get necessary infos for Can termination handling
    //*********************************************************************************************************************
    
    //Get amount of local IOs from OS
    udAmountLocalIOs      := OS_LOCALIO_GETCOUNT(pGPIO);
    udFoundRegisterIndex  := CP841_IOS_REGISTER_NOT_FOUND; //Register not found
    
    //Check if we found local IOs on the hardware
    if udAmountLocalIOs then
      
      //Now search all local IOs to find the correct registers of the "wb_cpu_reg" component
      for i:= 0 to udAmountLocalIOs-1 do
        result := OS_LOCALIO_GETINFO(pGPIO,i,#tmpLocalIOInfo);
        
        //Check if we found the correct component
        if (tmpLocalIOInfo.typeinfo AND 16#FFFF) = CP841_IOS_DEVICE_ID_CPU_REG then
        
          //We found it, save number and exit
          udFoundRegisterIndex := i;
          exit;
        end_if;
      end_for;

      //Check if we found the correct component
      if udFoundRegisterIndex <> CP841_IOS_REGISTER_NOT_FOUND then

        //Now we have to get the correct ID of both the "Clear" and the "Read/Set" Register
        //First local io we found is the Digital Input Reg because it is the first one in the adress mapping
        
        //Reg 0 ... Digital Input               ... udFoundRegisterIndex 
        //Reg 1 ... Digtal Output Clear         ... udFoundRegisterIndex + 1
        //Reg 2 ... Digital Output Read / Set   ... udFoundRegisterIndex + 2
        
        result := OS_LOCALIO_GETINFO(pGPIO,udFoundRegisterIndex + CP841_IOS_OFFSET_DIGITAL_OUTPUT_CLEAR_REGISTER,#sDigitalOutputClearRegisterInfo);
        
        //Check for errors
        if result <> 0 then
          udFoundRegisterIndex  := CP841_IOS_REGISTER_NOT_FOUND; //Register not found
        end_if;

        result := OS_LOCALIO_GETINFO(pGPIO,udFoundRegisterIndex + CP841_IOS_OFFSET_DIGITAL_OUTPUT_READ_SET_REGISTER,#sDigitalOutputReadSetRegisterInfo);

        //Check for errors
        if result <> 0 then
          udFoundRegisterIndex  := CP841_IOS_REGISTER_NOT_FOUND; //Register not found      
        end_if;
      end_if;
    end_if;

    
    //Write first time in init
    Can1_Termination.Write(input:=Can1_Termination);
    
    //*********************************************************************************************************************

  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL CP841_IOs::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
    VAR
    retval : DINT;
    sensorval : LSL_SENSOR_VALUE_TYPE;
    idx : e_SensorID;
  END_VAR

  //Check if initialisation was successfull -> so pointers must be valid and we don't need to check them
  if ClassState = 0 then
  
    for idx$UDINT := e_SensorID::IDVCC$UDINT to e_SensorID::IDTempCPUCore3$UDINT do
    
      retval := OS_SYSINFO_GET_PROPEX(pLSLSysInfo, LSL_SYSINFOEX_SENSORS_VALUE_GET, aSensors[idx].Handle, 0, #sensorval, sizeof(sensorval));
      if retval = LSL_SYSINFO_ERR_NONE Then
        aSensors[idx].pDst^ := sensorval.i32Value * aSensors[idx].Mul / aSensors[idx].Div;
      else
        aSensors[idx].pDst^ := ACCESS_DENIED;
      end_if;
    
    end_for;
    
    BatteryOk := p_XREGS^.Batt_funct$funct_XREGS_BattGood();

  else
    //Show on server that the information is not valid
    SupplyVoltage           := ACCESS_DENIED;    
    TemperatureFPGACore     := ACCESS_DENIED;
    TemperatureConnectors   := ACCESS_DENIED;
    TemperatureCPUBoard     := ACCESS_DENIED;
    TemperatureCPUCore0     := ACCESS_DENIED;
    TemperatureCPUCore1     := ACCESS_DENIED;
    TemperatureCPUCore2     := ACCESS_DENIED;
    TemperatureCPUCore3     := ACCESS_DENIED;
    RunLED                  := -1;
    ErrorLED                := -1;
    StatusLED               := -1;
  end_if;

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP841_IOs::RunLED::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if p_XREGS then
    if input >= 0 & input <= 3 then
      RunLED := input;
      bsLedValue := (RunLED$USINT AND 0x3) OR ((StatusLED$USINT AND 0x3) SHL 2) OR ((ErrorLED$USINT AND 0x3) SHL 4);
      p_XREGS^.LED_funct$funct_XREGS_SETLeds(val:= bsLedValue);
    end_if;
  end_if;

	result := RunLED;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP841_IOs::ErrorLED::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if p_XREGS then
    if input >= 0 & input <= 3 then
      ErrorLED := input;
      bsLedValue := (RunLED$USINT AND 0x3) OR ((StatusLED$USINT AND 0x3) SHL 2) OR ((ErrorLED$USINT AND 0x3) SHL 4);
      p_XREGS^.LED_funct$funct_XREGS_SETLeds(val:= bsLedValue);
    end_if;
  end_if;
  
	result := ErrorLED;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP841_IOs::StatusLED::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if p_XREGS then
    if input >= 0 & input <= 3 then
      StatusLED := input;
      bsLedValue := (RunLED$USINT AND 0x3) OR ((StatusLED$USINT AND 0x3) SHL 2) OR ((ErrorLED$USINT AND 0x3) SHL 4);
      p_XREGS^.LED_funct$funct_XREGS_SETLeds(val:= bsLedValue);
    end_if;
  end_if;
  
	result := StatusLED;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP841_IOs::Can1_Termination::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
    TmpRegValue : UDINT;
  END_VAR

  //Digitale Ausgänge
  //Bit 0: USB 0 einschalten (wird noch nicht verwendet)
  //Bit 1: USB 3.0 einschalten(wird noch nicht verwendet)
  //Bit 2: USB 2 einschalten(wird noch nicht verwendet)
  //Bit 3: USB 3 einschalten(wird noch nicht verwendet)
  //Bit 4: CPU Power BTN
  //Bit 5: Can TERM einschalten
  //Bit 6: SDIAS 24V einschalten
  //Bit 7: SDIAS 5V einschalten
  //Bit 15..8: Reserviert
  
  //Check if function is available
  if pGPIO & udFoundRegisterIndex <> CP841_IOS_REGISTER_NOT_FOUND then
        
    //Get current register value
    result$DINT := OS_GPIO_GETREG(pGPIO, sDigitalOutputReadSetRegisterInfo.id, CP841_IOS_OFFSET_DIGITAL_OUTPUT_READ_SET_REGISTER, #TmpRegValue);
    
    //Check for errors
    if result = 0 then
      
      //Register in FPGA is inverted
      //*****************************************************************************
      if input = 1 then
      
        TmpRegValue := 0x20;  //Only clear Bit 5
        
        result$DINT := OS_GPIO_SETREG(pGPIO, sDigitalOutputClearRegisterInfo.id, CP841_IOS_OFFSET_DIGITAL_OUTPUT_CLEAR_REGISTER, TmpRegValue);
        
        if result = 0 then
          Can1_Termination := 1;
        else
          Can1_Termination := -1; //Failed to set register
        end_if;

      //*****************************************************************************
      elsif input = 0 then
      
        TmpRegValue := TmpRegValue OR 0x20;  //Set current Bits and Bit 5
        
        result$DINT := OS_GPIO_SETREG(pGPIO, sDigitalOutputReadSetRegisterInfo.id, CP841_IOS_OFFSET_DIGITAL_OUTPUT_READ_SET_REGISTER, TmpRegValue);

        if result = 0 then
          Can1_Termination := 0;
        else
          Can1_Termination := -1; //Failed to set register
        end_if;
      end_if;
      //*****************************************************************************      
    else
      Can1_Termination := -1;
    end_if;
  else
    Can1_Termination := -1;
  end_if;
  
	result := Can1_Termination;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP841_IOs::USB_1_Connect::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	USB_1_Connect := XXXBase_IOs6.USB_1_Connect.Read();
	output := USB_1_Connect;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP841_IOs::CAN_1_Connect::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	CAN_1_Connect := XXXBase_IOs6.CAN_1_Connect.Read();
	output := CAN_1_Connect;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP841_IOs::Ethernet_1_Connect::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	Ethernet_1_Connect := XXXBase_IOs6.Ethernet_1_Connect.Read();
	output := Ethernet_1_Connect;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP841_IOs::Ethernet_2_Connect::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	Ethernet_2_Connect := XXXBase_IOs6.Ethernet_2_Connect.Read();
	output := Ethernet_2_Connect;

END_FUNCTION


FUNCTION CP841_IOs::CalcMulDiv100m
	VAR_INPUT
		unitfact 	: ESensorUnitFact;
		pSensor 	: ^t_Sensor;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  
  retval := - 1;
  // set mul div to convert to 0.1C
  pSensor^.Mul := 1;
  pSensor^.Div := 1;
  
  case unitfact of
    
    ESensorUnitFactNano:
      pSensor^.Div  := 100000000;
      retval        := 0;
    ESensorUnitFactMicro:
      pSensor^.Div  := 100000;
      retval        := 0;
    ESensorUnitFactMilli:
      pSensor^.Div  := 100;
      retval        := 0;
    ESensorUnitFactDef:    
      pSensor^.Mul  := 10;
      retval        := 0;
    ESensorUnitFactKilo:
      pSensor^.Mul  := 10000;
      retval        := 0;
    ESensorUnitFactMega:
      pSensor^.Mul  := 10000000;
      retval        := 0;
    ESensorUnitFactGiga:      
      // Multiplier does not fit in 4 Byte
      // pSensor^.Mul := 1000000000000
    ESensorUnitFactTera:
      // Multiplier does not fit in 4 Byte
      // pSensor^.Mul := 1000000000000000
  end_case;
    
END_FUNCTION


FUNCTION CP841_IOs::CalcMulDiv1m
	VAR_INPUT
		unitfact 	: ESensorUnitFact;
		pSensor 	: ^t_Sensor;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  
  retval := - 1;
  // set mul div to convert to mV
  pSensor^.Mul := 1;
  pSensor^.Div := 1;
  
  case unitfact of
    
    ESensorUnitFactNano:
      pSensor^.Div  := 1000000;
      retval        := 0;
    ESensorUnitFactMicro:
      pSensor^.Div  := 1000;
      retval        := 0;
    ESensorUnitFactMilli:
      pSensor^.Div  := 1;
      retval        := 0;
    ESensorUnitFactDef:    
      pSensor^.Mul  := 1000;
      retval        := 0;
    ESensorUnitFactKilo:
      pSensor^.Mul  := 1000000;
      retval        := 0;
    ESensorUnitFactMega:
      pSensor^.Mul  := 1000000000;
      retval        := 0;
    ESensorUnitFactGiga:      
      // Multiplier does not fit in 4 Byte
      // pSensor^.Mul := 1000000000000
    ESensorUnitFactTera:
      // Multiplier does not fit in 4 Byte
      // pSensor^.Mul := 1000000000000000
  end_case;

END_FUNCTION
